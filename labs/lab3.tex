\section{Lab 3: \practicalThreeTitle}
\topics{Recursive \& higher-order functions and monoids.}

This practical is mainly about recursive and higher-order functions in Haskell. You can obtain the skeleton code for this lab by cloning the repository from GitHub:
\begin{minted}{bash}
$ git clone https://github.com/fpclass/lab3
\end{minted}
In a nutshell, recursive functions are functions which are defined in terms of themselves. Higher-order functions are functions which take other functions as arguments or return functions.

\taskLine

\task[task:higher-order-typings]{For each of the following statements, discuss with someone (friend, tutor, rubber duck, etc.) whether it is true or false:
\begin{enumerate}
\item A function of type \mintinline{text}{a -> b -> c} returns a function.
\item A function of type \mintinline{text}{(a -> b) -> Int} returns a function. 
\item A function of type \mintinline{text}{(Int, Bool) -> Char} is higher-order.
\item A function of type \mintinline{text}{a -> a} can be a higher-order function.
\end{enumerate}
}

\taskLine

\subsubsection{Recursive and higher-order functions}

In the fifth lecture, you learnt how to write functions using \emph{explicit recursion}, as demonstrated in the definition of \haskellIn{and} below:
\begin{minted}{haskell}
and :: [Bool] -> Bool
and []     = True 
and (x:xs) = x && and xs
\end{minted}
You also learnt how to use higher-order functions to abstract over common patterns in the sixth lecture. For example, you could define \haskellIn{and} with the help of \haskellIn{foldr} as the following, in which case the recursion is not explicit:
\begin{minted}{haskell}
and :: [Bool] -> Bool 
and = foldr (&&) True
\end{minted} 

\taskLine

\task[task:elem-explicit]{Using explicit recursion, complete the definition of 
	
\haskellIn{elem :: Eq a => a -> [a] -> Bool}

which should determine whether some value of type \texttt{\small a} is contained in a list of values of type \texttt{\small a}. For example, \haskellIn{elem 4 [4,8,15,4]} should evaluate to \haskellIn{True} and \haskellIn{elem 7 [4,8,15,4]} should evaluate to \haskellIn{False}.}

\task[task:elem-composition]{Now try to define \haskellIn{elem} entirely in terms of the following standard library functions: \haskellIn{not}, \haskellIn{null}, \haskellIn{filter} with an appropriate predicate, and function composition.} 

\taskLine

\task{Using explicit recursion, complete the definition of}

\haskellIn{maximum :: Ord a => [a] -> a}

which should find the greatest element of the list given as argument. For example, \haskellIn{maximum [1,2,3,2,1]} should evaluate to \haskellIn{3}. You may assume that \haskellIn{maximum} will never be called with the empty list so you do not need to define an equation for that case.

\task{The \haskellIn{foldr1 :: (a -> a -> a) -> [a] -> a} function behaves like \haskellIn{foldr}, except that it assumes lists always have at least one element. It therefore only requires a binary operation and a list as arguments. Implement \haskellIn{maximum} using \haskellIn{foldr1}.}

\taskLine 

\task{Complete the definition of

\haskellIn{intersperse :: a -> [a] -> [a]}

which should separate elements of a list with some separator of the same type as the elements of the list. For example, \haskellIn{intersperse '|' "WITTER"} should evaluate to \haskellIn{"W|I|T|T|E|R"}.

\emph{Hint}: you may find it useful to define an additional function to help you.
}

\taskLine

\task{Complete the definition of \haskellIn{any}, which should test whether at least one element of the list given as argument satisfies the predicate. For example, \haskellIn{any even [1,2,3]} should evaluate to \haskellIn{True}.}

\task{Can you define \haskellIn{elem} using only \haskellIn{any} with an appropriate predicate?}

\taskLine

\task{Complete the definition of \haskellIn{all}, which should test whether all elements of the list given as argument satisfy the predicate. For example, \haskellIn{all odd [1,3,5]} should evaluate to \haskellIn{True}.}

\taskLine

\task{Implement the \haskellIn{flip} function which, given a function with two parameters as argument, produces a function with the parameters flipped. Note: there are no unit tests for this function, but your implementation will be correct if it is well typed according to the typing in the skeleton code.}

\taskLine 

\task{Complete the definition of 
	
\haskellIn{takeWhile :: (a -> Bool) -> [a] -> [a]} 

which generalises the \haskellIn{take} function to a predicate: \haskellIn{takeWhile} should take elements from the list argument and return them while the predicate holds. For example, \haskellIn{takeWhile (< 3) [1,2,3,2,1]} should evaluate to \haskellIn{[1,2]}. 
}

\taskLine 

\task{Complete the definition of \haskellIn{zipWith}, which generalises \haskellIn{zip}. While \haskellIn{zip} puts elements from two lists into pairs in a resulting list, \haskellIn{zipWith} requires a function of type \haskellIn{a -> b -> c} as argument which combines elements of type \texttt{\small a} from the first list and elements of type \texttt{\small b} from the second list into elements of type \texttt{\small c} for the resulting list. For example, \haskellIn{zipWith replicate [1,2,3] ['a', 'b', 'c']} should evaluate to \haskellIn{[['a'], ['b', 'b'], ['c', 'c', 'c']]}.}

\taskLine 

\task{Complete the definition of \haskellIn{groupBy}, which should group elements of a list according to some predicate. For example, \haskellIn{groupBy (==) [1,2,2,3,4,4,1]} should evaluate to \haskellIn{[[1], [2,2], [3], [4,4], [1]]}.}

\taskLine

\task{Complete the definition of
	
\haskellIn{subsequences :: [a] -> [[a]]}
	
which should find all possible subsequences of the argument. For example, evaluating \haskellIn{subsequences "abc"} should result in a list such as \linebreak \haskellIn{["", "a", "b", "c", "ab", "bc", "ac", "abc"]}. The order of the elements in the resulting list does not matter.
} 

\taskLine

\task{Complete the definition of
	
\haskellIn{permutations :: Eq a => [a] -> [[a]]}
	
which should find all possible permutations of the argument. For example, evaluating \haskellIn{permutations "abc"} should result in a list such as \linebreak \haskellIn{["abc", "acb", "bac", "bca", "cab", "cba"]}. The order of the elements in the resulting list does not matter.
} 

\task{Could you implement \haskellIn{permutations} without the \haskellIn{Eq} constraint on \texttt{\small a}?}

\taskLine 

\subsubsection{Monoids}

A \emph{monoid} is an algebraic structure which consists of a unit value and an associative, binary operation. In Haskell, we can declare a type class for types which are monoids:
\begin{minted}{haskell}
class Monoid a where
    mempty  :: a
    mappend :: a -> a -> a
    mconcat :: [a] -> a
\end{minted}
Here, \texttt{mempty} represents the unit value and \texttt{mappend} represents the associative, binary operation. Instances of the \texttt{Monoid} type class should obey the following \emph{monoid laws}:
\begin{displaymath}
\begin{array}{lcrcl}
\textbf{Left identity} &\qquad & \mathit{mappend}~\mathit{mempty}~x & = & x \\
\textbf{Right identity} &\qquad & \mathit{mappend}~x~\mathit{mempty} & = & x \\
\textbf{Associativity} & \qquad & \mathit{mappend}~x~(\mathit{mappend}~y~z) & = & \mathit{mappend}~(\mathit{mappend}~x~y)~z \\
\textbf{Concatenation} & \qquad & \mathit{mconcat} & = & \mathit{foldr}~\mathit{mappend}~\mathit{mempty}
\end{array}
\end{displaymath}
We say that a type \emph{forms} a monoid if there is an instance of the \haskellIn{Monoid} type class for it which obeys the monoid laws. 

The \haskellIn{mconcat} function shown above is not necessary for a type to be a monoid, but it generalises the ordinary \haskellIn{concat} function on lists of lists and can easily be implemented with the help of \haskellIn{mappend} and \haskellIn{mempty}.

\taskLine 

\task{The \haskellIn{mconcat} function does nothing specific to any particular type. Specify a default implementation for the \haskellIn{mconcat} function in the declaration of the \haskellIn{Monoid} type class so that it obeys the fourth monoid law.}

\task{Does it matter whether you use \haskellIn{foldr} or \haskellIn{foldl} for the implementation of \haskellIn{mconcat}?}

\taskLine

\task{Implement \haskellIn{mempty} and \haskellIn{mappend} of the \haskellIn{Monoid} instance for \haskellIn{Int} so that they obey the monoid laws. Note that there are two possible implementations which satisfy the monoid laws -- can you think of both?}

\taskLine 

\task{Implement \haskellIn{mempty} and \haskellIn{mappend} of the \haskellIn{Monoid} instance for \texttt{\small [a]} so that they obey the monoid laws.}

\taskLine 

\task{Functions of type \texttt{\small a -> b} form a monoid if \texttt{\small b} is a monoid. Implement \haskellIn{mempty} and \haskellIn{mappend} of the \haskellIn{Monoid} instance for \texttt{\small a -> b} so that they obey the monoid laws. Note that there are no unit tests for this task as it would require tests for function equality.}

\taskLine 
