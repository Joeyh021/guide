
% lecture 1
\newcommand{\lectureOneTitle}{Introduction}
\newcommand{\lectureOneDate}{7 January}
\newcommand{\lectureOneQuestion}{What is functional programming and why should we learn it?}
\newcommand{\lectureOneTopics}{Overview of programming paradigms \& models of computation, examples of applications of functional programming, module overview, and recommended texts.}

% lecture 2
\newcommand{\lectureTwoTitle}{Definitions \& functions}
\newcommand{\lectureTwoDate}{8 January}
\newcommand{\lectureTwoQuestion}{How do we write simple programs in Haskell?}
\newcommand{\lectureTwoTopics}{Definitions, basic arithmetic expressions, string values, boolean values, functions, using built-in functions, and basic pattern matching.}

% lecture 3
\newcommand{\lectureThreeTitle}{Basic types}
\newcommand{\lectureThreeDate}{9 January}
\newcommand{\lectureThreeQuestion}{How does the compiler prevent us from writing bad software?}
\newcommand{\lectureThreeTopics}{Basic types, function types, parametric polymorphism, lists, and pairs.}

% lecture 3b
\newcommand{\lectureThreeBTitle}{Lists}
\newcommand{\lectureThreeBDate}{14 January}
\newcommand{\lectureThreeBQuestion}{How do we use lists in Haskell?}
\newcommand{\lectureThreeBTopics}{Constructing lists, pattern-matching on lists, and list comprehensions.}

% lecture 4
\newcommand{\lectureFourTitle}{Type classes}
\newcommand{\lectureFourDate}{15 January}
\newcommand{\lectureFourQuestion}{How can we restrict polymorphism and overload functions?}
\newcommand{\lectureFourTopics}{Ad-hoc polymorphism via type classes, built-in type classes, and type class constraints.}

% lecture 5
\newcommand{\lectureFiveTitle}{Recursive functions}
\newcommand{\lectureFiveDate}{16 January}
\newcommand{\lectureFiveQuestion}{How do we express loops without mutable state?}
\newcommand{\lectureFiveTopics}{Writing recursive functions for basic types (numbers, lists/strings), defining built-in functions ourselves.}

% lecture 6
\newcommand{\lectureSixTitle}{Higher-order functions}
\newcommand{\lectureSixDate}{21 January}
\newcommand{\lectureSixQuestion}{Can we write functions which abstract over common behaviours?}
\newcommand{\lectureSixTopics}{Higher-order functions such as \haskellIn{map}, \haskellIn{filter}, etc., recursion primitives such as \haskellIn{foldr} and \haskellIn{foldl}.}

% lecture 7
\newcommand{\lectureSevenTitle}{Data types \& type aliases}
\newcommand{\lectureSevenDate}{22 January}
\newcommand{\lectureSevenQuestion}{How can we define our own types in Haskell?}
\newcommand{\lectureSevenTopics}{Type aliases, data types, data constructors, pattern matching on custom data constructors, recursion on values of custom types.}

% lecture 8
\newcommand{\lectureEightTitle}{Coursework 1 briefing}
\newcommand{\lectureEightDate}{23 January}
\newcommand{\lectureEightQuestion}{What is the first coursework about?}
\newcommand{\lectureEightTopics}{Demonstration of what the completed coursework will do, five-guess algorithm, introduction to the skeleton code.}

% lecture 9
\newcommand{\lectureNineTitle}{Lazy evaluation}
\newcommand{\lectureNineDate}{28 January}
\newcommand{\lectureNineQuestion}{What order are programs evaluated in?}
\newcommand{\lectureNineTopics}{Strict and lazy evaluation, calling conventions, benefits and disadvantages, and examples of lazy evaluation.}

% lecture 9b
\newcommand{\lectureNineBTitle}{\emph{Fun with} testing}
\newcommand{\lectureNineBDate}{29 January}
\newcommand{\lectureNineBQuestion}{What tools are there for testing and how do we use them?}
\newcommand{\lectureNineBTopics}{Unit testing and property-based testing in Haskell.}

% lecture 10
\newcommand{\lectureTenTitle}{Reasoning about programs}
\newcommand{\lectureTenDate}{30 January}
\newcommand{\lectureTenQuestion}{Can we use formal reasoning techniques to prove properties about our programs?}
\newcommand{\lectureTenTopics}{Equational reasoning, proofs by induction.}

% lecture 11
\newcommand{\lectureElevenTitle}{Reasoning about programs (cont.)}
\newcommand{\lectureElevenDate}{4 February}
\newcommand{\lectureElevenQuestion}{Can we use formal reasoning techniques to prove properties about our programs?}
\newcommand{\lectureElevenTopics}{Equational reasoning, proofs by induction.}

% lecture 11b
\newcommand{\lectureElevenBTitle}{\emph{Fun with} constructive induction}
\newcommand{\lectureElevenBDate}{5 February}
\newcommand{\lectureElevenBQuestion}{Can we use formal reasoning techniques to calculate more efficient programs?}
\newcommand{\lectureElevenBTopics}{Constructive induction.}

% lecture 12
\newcommand{\lectureTwelveTitle}{Functors \& applicative functors}
\newcommand{\lectureTwelveDate}{6 February}
\newcommand{\lectureTwelveQuestion}{Are there any useful design patterns in functional programming?}
\newcommand{\lectureTwelveTopics}{Functors, applicative functions, applications of applicative functors.}

% lecture 12b
\newcommand{\lectureTwelveBTitle}{Functors \& applicative functors (cont.)}
\newcommand{\lectureTwelveBDate}{11 February}
\newcommand{\lectureTwelveBQuestion}{Are there any useful design patterns in functional programming?}
\newcommand{\lectureTwelveBTopics}{Functors, applicative functions, applications of applicative functors.}

% lecture 12c
\newcommand{\lectureTwelveCTitle}{\emph{Fun with} applicative functors}
\newcommand{\lectureTwelveCDate}{12 February}
\newcommand{\lectureTwelveCQuestion}{What can we do with applicative functors?}
\newcommand{\lectureTwelveCTopics}{Applicative functors in action.}

% lecture 12d
\newcommand{\lectureTwelveDTitle}{Coursework 2 briefing}
\newcommand{\lectureTwelveDDate}{13 February}
\newcommand{\lectureTwelveDQuestion}{What is the second coursework about?}
\newcommand{\lectureTwelveDTopics}{Demonstration of what the completed coursework will do, semantics of the programming language, introduction to the skeleton code.}

% lecture 13
\newcommand{\lectureThirteenTitle}{Foldables}
\newcommand{\lectureThirteenDate}{18 February}
\newcommand{\lectureThirteenQuestion}{Are there any other useful design patterns in functional programming?}
\newcommand{\lectureThirteenTopics}{\haskellIn{Foldable} type class, its motivation, and examples.}

% lecture 14
\newcommand{\lectureFourteenTitle}{Sequential composition}
\newcommand{\lectureFourteenDate}{19 February}
\newcommand{\lectureFourteenQuestion}{How do structure programs in which one part of a program relies on the result of another part?}
\newcommand{\lectureFourteenTopics}{Some functions for the sequential composition of \texttt{\small Maybe} values.}

% lecture 15
\newcommand{\lectureFifteenTitle}{Sequential composition (cont.)}
\newcommand{\lectureFifteenDate}{25 February}
\newcommand{\lectureFifteenQuestion}{Are there other examples of sequential composition?}
\newcommand{\lectureFifteenTopics}{Some functions for the sequential composition of \texttt{\small State} values and some laws for sequential composition.}

% lecture 16
\newcommand{\lectureSixteenTitle}{\emph{Fun with} sequential composition}
\newcommand{\lectureSixteenDate}{26 February}
\newcommand{\lectureSixteenQuestion}{How is sequential composition used in practice?}
\newcommand{\lectureSixteenTopics}{Sequential composition in action.}

% lecture 17
\newcommand{\lectureSeventeenTitle}{Input and output}
\newcommand{\lectureSeventeenDate}{27 February}
\newcommand{\lectureSeventeenQuestion}{Can we write impure programs in a pure programming language?}
\newcommand{\lectureSeventeenTopics}{The \texttt{\small IO} monad.}

% lecture 18
\newcommand{\lectureEighteenTitle}{Type promotion \& GADTs}
\newcommand{\lectureEighteenDate}{4 March}
\newcommand{\lectureEighteenQuestion}{How can we encode more information in types?}
\newcommand{\lectureEighteenTopics}{Phantom types, GADTs, singleton types, pattern matching with GADTs.}

% lecture 18b
\newcommand{\lectureEighteenBTitle}{\emph{Fun with} IO}
\newcommand{\lectureEighteenBDate}{5 March}
\newcommand{\lectureEighteenBQuestion}{What do Haskell programs that make use of IO look like?}
\newcommand{\lectureEighteenBTopics}{The \texttt{\small IO} monad in action.}

% lecture 19
\newcommand{\lectureNineteenTitle}{Type families}
\newcommand{\lectureNineteenDate}{6 March}
\newcommand{\lectureNineteenQuestion}{How can we perform computation at the type-level?}
\newcommand{\lectureNineteenTopics}{Closed and open type families.}

% lecture 20
\newcommand{\lectureTwentyTitle}{Type-level programming}
\newcommand{\lectureTwentyDate}{11 March}
\newcommand{\lectureTwentyQuestion}{How do we make type-level programming practical in Haskell?}
\newcommand{\lectureTwentyTopics}{Singletons, proxies, and reification.}

% lecture 21
\newcommand{\lectureTwentyOneTitle}{\emph{Fun with} type-level programming}
\newcommand{\lectureTwentyOneDate}{12 March}
\newcommand{\lectureTwentyOneQuestion}{What are some examples of how type-level programming is used?}
\newcommand{\lectureTwentyOneTopics}{Type-level programming in action.}

% lecture 22
\newcommand{\lectureTwentyTwoTitle}{Conclusions}
\newcommand{\lectureTwentyTwoDate}{13 March}
\newcommand{\lectureTwentyTwoQuestion}{What have we learnt about functional programming?}
\newcommand{\lectureTwentyTwoTopics}{Summary of the module, information about the exam, and other general information.}

% practical 1
\newcommand{\practicalOneTitle}{Getting started}
\newcommand{\practicalOneDate}{7-11 January}
\newcommand{\practicalOneAims}{You will learn how to use some of the tools that we will be using as part of this module.}

% practical 2
\newcommand{\practicalTwoTitle}{Types \& list comprehensions}
\newcommand{\practicalTwoDate}{14-18 January}
\newcommand{\practicalTwoAims}{This lab teaches you to understand type errors and how to fix them. You will also learn about list comprehensions.}

% practical 3
\newcommand{\practicalThreeTitle}{Recursive \& higher-order functions}
\newcommand{\practicalThreeDate}{21-25 January}
\newcommand{\practicalThreeAims}{By the end of this lab, you should be able to solve problems by writing recursive and higher-order functions.}

% practical 4
\newcommand{\practicalFourTitle}{User-defined types}
\newcommand{\practicalFourDate}{\parbox{2.2cm}{28 January-\linebreak 1 February}}
\newcommand{\practicalFourAims}{You will define your own types and functions which work with them.}

% practical 5
\newcommand{\practicalFiveTitle}{Lazy evaluation and equational reasoning}
\newcommand{\practicalFiveDate}{4-8 February}
\newcommand{\practicalFiveAims}{The goal of this lab is for you to be able to write programs which make effective use of lazy evaluation, such as for backtracking or infinite data. You will also prove some properties about your programs using equational reasoning and structural induction.}

% practical 6
\newcommand{\practicalSixTitle}{Functors}
\newcommand{\practicalSixDate}{11-15 February}
\newcommand{\practicalSixAims}{You will write programs using functors.}

% practical 6b
\newcommand{\practicalSixBTitle}{Applicative functors}
\newcommand{\practicalSixBDate}{18-22 February}
\newcommand{\practicalSixBAims}{You will write programs using applicative functors.}

% practical 7
\newcommand{\practicalSevenTitle}{Foldables}
\newcommand{\practicalSevenDate}{\parbox{2.4cm}{25 February-\linebreak 1 March}}
\newcommand{\practicalSevenAims}{In this lab, you will write programs using foldables.}

% practical 8
\newcommand{\practicalEightTitle}{Effectful programs}
\newcommand{\practicalEightDate}{4-8 March}
\newcommand{\practicalEightAims}{You will write programs using monads, define your own instances of the \haskellIn{Monad} type class, and reason about monad laws.}

% practical 9
\newcommand{\practicalNineTitle}{Type-level programming}
\newcommand{\practicalNineDate}{11-15 March}
\newcommand{\practicalNineAims}{You should be able to write simple programs at the type-level using GADTs and type families.}